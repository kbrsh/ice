'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _spdy = require('spdy');

var _spdy2 = _interopRequireDefault(_spdy);

var _nodeFetch = require('node-fetch');

var _nodeFetch2 = _interopRequireDefault(_nodeFetch);

var _url = require('url');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Returns a `fetch` version with a similar
 * API to the browser's configured with a
 * HTTP2 agent.
 *
 * It encodes `body` automatically as JSON.
 *
 * @param {String} host
 * @return {Function} fetch
 */

var Agent = function () {
  function Agent(url) {
    var _ref = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    var _ref$tls = _ref.tls;
    var tls = _ref$tls === undefined ? true : _ref$tls;
    var debug = _ref.debug;
    (0, _classCallCheck3.default)(this, Agent);

    this._url = url;
    var parsed = (0, _url.parse)(url);
    this._host = parsed.hostname;
    this._port = parsed.port;
    this._protocol = parsed.protocol;
    this._debug = debug;
    if (tls) this._initAgent();
  }

  (0, _createClass3.default)(Agent, [{
    key: '_initAgent',
    value: function _initAgent() {
      var _this = this;

      if ('https:' !== this._protocol) return;

      this._agent = _spdy2.default.createAgent({
        host: this._host,
        port: this._port || 443
      }).once('error', function (err) {
        return _this._onError(err);
      });
    }
  }, {
    key: '_onError',
    value: function _onError(err) {
      // XXX: should we `this.emit()`?
      if (this._debug) {
        console.log('> [debug] agent connection error', err.stack);
      }
      this._error = err;
    }
  }, {
    key: 'fetch',
    value: function fetch(path) {
      var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      if (this._error) {
        if (this._debug) console.log('> [debug] re-initializing agent after error');
        this._error = null;
        this._initAgent();
      }

      var body = opts.body;

      if (this._agent) {
        opts.agent = this._agent;
      }

      if (body && 'object' === (typeof body === 'undefined' ? 'undefined' : (0, _typeof3.default)(body)) && 'function' !== typeof body.pipe) {
        opts.headers['Content-Type'] = 'application/json';
        opts.body = (0, _stringify2.default)(body);
      }

      if (null != opts.body && 'function' !== typeof body.pipe) {
        opts.headers['Content-Length'] = Buffer.byteLength(opts.body);
      }

      return (0, _nodeFetch2.default)(this._url + path, opts);
    }
  }, {
    key: 'close',
    value: function close() {
      if (this._debug) console.log('> [debug] closing agent');
      if (this._agent) {
        this._agent.close();
      }
    }
  }]);
  return Agent;
}();

exports.default = Agent;